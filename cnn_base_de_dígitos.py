# -*- coding: utf-8 -*-
"""CNN - Base de Dígitos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nQ8HjcHyMV0HF1llen0dUK8VB_A2nbJs
"""

#CNN = Rede Neural Convolucional
#importação das bibliotecas utilizadas
import tensorflow 
from tensorflow import keras
from keras.models import model_from_json
import matplotlib.pyplot as plt
from keras.layers import Dense, Flatten, Conv2D, MaxPooling2D
import numpy as np

#importa o dataset de dígitos 
dataset = keras.datasets.mnist
((imagens_treino, classes_treino), (imagens_teste, classes_teste)) = dataset.load_data()

print("imagens de Treino:" ,len(imagens_treino))
print("imagens de Treino:" ,imagens_treino.shape)
print("imagens de Teste:" ,imagens_teste.shape)
print("classes de Treino:" ,classes_treino.shape)

print("min: ", classes_treino.min())
print("max: ", classes_treino.max())

nomes_de_classificacoes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

total_de_classificacoes=10

fig, axes = plt.subplots(figsize=(10,5))
fig.tight_layout()

for imagem in range(10):
   plt.subplot(2, 5, imagem+1)
   plt.imshow(imagens_treino[imagem])
   plt.title(nomes_de_classificacoes[classes_treino[imagem]])

plt.imshow(imagens_treino[0])
plt.colorbar()

print(imagens_treino.shape)
imagens_treino = imagens_treino.reshape((imagens_treino.shape[0],28,28,1))#redefino o formato para 1 vetor
imagens_teste = imagens_teste.reshape((imagens_teste.shape[0],28,28,1))#[0] é o 60000
print(imagens_treino.shape)

#normalização
imagens_treino = imagens_treino/255
#Convolução 2D => 32 = KERNELS, (3,3) =tamanho do kernel, input = (imagem 28x28 o 1 é obrigatório da biblioteca, já está em escala de cinza), função de ativação = relu(entrada negativa? converte em zero e o neuronio não é carregado)
modelo = keras.Sequential([keras.layers.Conv2D(32,(3,3), input_shape=(28,28,1), activation=tensorflow.nn.relu),
                           keras.layers.MaxPooling2D((2,2)),#trata a questão de diversos angulos da imagem
                           keras.layers.Flatten(),#transforma a imagem 28x28 em 1D para a entrada
                           keras.layers.Dense(100, activation=tensorflow.nn.relu),#camada oculta
                           keras.layers.Dense(50, activation=tensorflow.nn.relu),#camada oculta
                           keras.layers.Dropout(0.2),#barra o overfitting
                           keras.layers.Dense(10, activation=tensorflow.nn.softmax)#na essencia dá a probabilidade de a entrada estar em uma determinada classe
                           ])
#compila
adam=keras.optimizers.Adam(lr=0.5)
modelo.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')

hist=modelo.fit(imagens_treino, classes_treino, epochs=10, validation_split=0.2)

plt.plot(hist.history['accuracy'])
plt.plot(hist.history['val_accuracy'])
plt.title('Acurácia por épocas')
plt.xlabel('Épocas')
plt.ylabel('Acurácia')
plt.legend(['Treino', 'Validação'])

plt.plot(hist.history['loss'])
plt.plot(hist.history['val_loss'])
plt.title('Loss por épocas')
plt.xlabel('Épocas')
plt.ylabel('Loss')
plt.legend(['Treino', 'Validação'])

model_json = modelo.to_json()
with open("model.json", "w") as json_file:
   json_file.write(model_json)

modelo.save_weights("model.h5")
print("Modelo Salvo")

json_file = open("model.json", "r")
loaded_model_json = json_file.read()
json_file.close()

loaded_model = model_from_json(loaded_model_json)
loaded_model.load_weights("model.h5")
print("Modelo Carregado")

loaded_model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')

perda_teste, acuracia_teste = loaded_model.evaluate(imagens_teste, classes_teste)
print("Perda do teste: ", perda_teste)
print("Acurácia do teste: ", acuracia_teste)
testes=loaded_model.predict(imagens_teste/255)

x=0
arr=[]
for i in testes:
   #print(i)
   print(nomes_de_classificacoes[np.argmax(i)], np.max(i), nomes_de_classificacoes[classes_teste[x]])
   
   if (nomes_de_classificacoes[np.argmax(i)] != nomes_de_classificacoes[classes_teste[x]]):
      arr.append([nomes_de_classificacoes[np.argmax(i)], nomes_de_classificacoes[classes_teste[x]], imagens_teste[x]])
   x=x+1